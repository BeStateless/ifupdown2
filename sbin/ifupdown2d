#!/usr/bin/python
#
# Copyright 2014 Cumulus Networks, Inc. All rights reserved.
# Authors:
#           Roopa Prabhu, roopa@cumulusnetworks.com
#           Julien Fortin, julien@cumulusnetworks.com
#
# ifupdown2 --
#    tool to configure network interfaces
#

import os
import re
import json
import fcntl
import struct
import signal
import socket
import daemon
import select
import StringIO
import resource
import datetime
import threading
import ConfigParser

from ifupdown.log import log

import ifupdown.argv

_SIGINT = signal.getsignal(signal.SIGINT)
_SIGTERM = signal.getsignal(signal.SIGTERM)
_SIGQUIT = signal.getsignal(signal.SIGQUIT)

configmap_g = None


class Ifupdown2:
    CONFIGFILE = "/etc/network/ifupdown2/ifupdown2.conf"
    ENVPATH = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

    def __init__(self, client_uid):
        self.uid = client_uid

        self.args = None
        self.op = None

        self.interfaces_filename = None
        self.interfaces_file_iobuf = None

        self.handlers = {
            'up': self.run_up,
            'down': self.run_down,
            'query': self.run_query,
            'reload': self.run_reload
        }

    def set_signal_handlers(self):
        signal.signal(signal.SIGQUIT, _SIGQUIT)
        signal.signal(signal.SIGTERM, _SIGTERM)
        signal.signal(signal.SIGINT, _SIGINT)

    def parse_argv(self, argv):
        args_parse = ifupdown.argv.Parse(argv)
        args_parse.validate()

        self.args = args_parse.get_args()
        self.op = args_parse.get_op()

    def update_logger(self, client_socket):
        syslog = self.args.syslog if hasattr(self.args, 'syslog') else False
        log.update_current_logger(syslog=syslog,
                                  verbose=self.args.verbose,
                                  debug=self.args.debug)
        log.set_socket(client_socket)

    def main(self, request):
        if self.op != 'query' and self.uid != 0:
            raise Exception('must be root to run this command')

        try:
            self.read_config()
            self.init(request)
            self.handlers.get(self.op)(self.args)
        except Exception, e:
            if not str(e):
                return 1
                # if args and args.debug:
                raise
            # else:
            if log:
                log.error(str(e))
            else:
                print str(e)
                # if args and not args.debug:
                #    print '\nrerun the command with \'-d\' for a detailed errormsg'
            return 1
        return 0

    def init(self, request):
        if hasattr(self.args, 'interfacesfile') and self.args.interfacesfile != None:
            # Check to see if -i option is allowed by config file
            # But for ifquery, we will not check this
            if (not self.op == 'query' and
                        configmap_g.get('disable_cli_interfacesfile', '0') == '1'):
                log.error('disable_cli_interfacesfile is set so users '
                          'not allowed to specify interfaces file on cli.')
                raise Exception("")
            if self.args.interfacesfile == '-':
                # If interfaces file is stdin, read
                self.interfaces_file_iobuf = request['stdin']
            else:
                self.interfaces_filename = self.args.interfacesfile
        else:
            # if the ifupdown2 config file does not have it, default to standard
            self.interfaces_filename = configmap_g.get('default_interfaces_configfile',
                                                       '/etc/network/interfaces')

    def read_config(self):
        global configmap_g

        with open(Ifupdown2.CONFIGFILE, 'r') as f:
            config = f.read()
        configStr = '[ifupdown2]\n' + config
        configFP = StringIO.StringIO(configStr)
        parser = ConfigParser.RawConfigParser()
        parser.readfp(configFP)
        configmap_g = dict(parser.items('ifupdown2'))

        # Preprocess config map
        configval = configmap_g.get('multiple_vlan_aware_bridge_support', '0')
        if configval == '0':
            # if multiple bridges not allowed, set the bridge-vlan-aware
            # attribute in the 'no_repeats' config, so that the ifupdownmain
            # module can catch it appropriately
            configmap_g['no_repeats'] = {'bridge-vlan-aware': 'yes'}

        configval = configmap_g.get('link_master_slave', '0')
        if configval == '1':
            # link_master_slave is only valid when all is set
            if hasattr(self.args, 'all') and not self.args.all:
                configmap_g['link_master_slave'] = '0'

        configval = configmap_g.get('delay_admin_state_change', '0')
        if configval == '1':
            # reset link_master_slave if delay_admin_state_change is on
            configmap_g['link_master_slave'] = '0'

    def run_up(self, args):
        log.debug('args = %s' % str(args))

        try:
            iflist = args.iflist
            if len(args.iflist) == 0:
                iflist = None
            log.debug('creating ifupdown object ..')
            cachearg = (False if (iflist or args.nocache or
                                  args.perfmode or args.noact)
                        else True)
            import ifupdown.ifupdownmain
            ifupdown_handle = ifupdown.ifupdownmain.ifupdownMain(config=configmap_g,
                                                                 force=args.force,
                                                                 withdepends=args.withdepends,
                                                                 perfmode=args.perfmode,
                                                                 dryrun=args.noact,
                                                                 cache=cachearg,
                                                                 addons_enable=not args.noaddons,
                                                                 statemanager_enable=not args.noaddons,
                                                                 interfacesfile=self.interfaces_filename,
                                                                 interfacesfileiobuf=self.interfaces_file_iobuf,
                                                                 interfacesfileformat=args.interfacesfileformat)
            if args.noaddons:
                ifupdown_handle.up(['up'], args.all, args.CLASS, iflist,
                                   excludepats=args.excludepats,
                                   printdependency=args.printdependency,
                                   syntaxcheck=args.syntaxcheck, type=args.type,
                                   skipupperifaces=args.skipupperifaces)
            else:
                ifupdown_handle.up(['pre-up', 'up', 'post-up'],
                                   args.all, args.CLASS, iflist,
                                   excludepats=args.excludepats,
                                   printdependency=args.printdependency,
                                   syntaxcheck=args.syntaxcheck, type=args.type,
                                   skipupperifaces=args.skipupperifaces)
        except:
            raise

    def run_down(self, args):
        log.debug('args = %s' % str(args))

        try:
            iflist = args.iflist
            log.debug('creating ifupdown object ..')
            import ifupdown.ifupdownmain
            ifupdown_handle = ifupdown.ifupdownmain.ifupdownMain(config=configmap_g, force=args.force,
                                                                 withdepends=args.withdepends,
                                                                 perfmode=args.perfmode,
                                                                 dryrun=args.noact,
                                                                 addons_enable=not args.noaddons,
                                                                 statemanager_enable=not args.noaddons,
                                                                 interfacesfile=self.interfaces_filename,
                                                                 interfacesfileiobuf=self.interfaces_file_iobuf,
                                                                 interfacesfileformat=args.interfacesfileformat)

            ifupdown_handle.down(['pre-down', 'down', 'post-down'],
                                 args.all, args.CLASS, iflist,
                                 excludepats=args.excludepats,
                                 printdependency=args.printdependency,
                                 usecurrentconfig=args.usecurrentconfig,
                                 type=args.type)
        except:
            raise

    def run_query(self, args):
        log.debug('args = %s' % str(args))

        try:
            iflist = args.iflist
            if args.checkcurr:
                qop = 'query-checkcurr'
            elif args.running:
                qop = 'query-running'
            elif args.raw:
                qop = 'query-raw'
            elif args.syntaxhelp:
                qop = 'query-syntax'
            elif args.printdependency:
                qop = 'query-dependency'
            elif args.printsavedstate:
                qop = 'query-savedstate'
            else:
                qop = 'query'
            cachearg = (False if (iflist or args.nocache or
                                  args.perfmode or args.syntaxhelp or
                                  (qop != 'query-checkcurr' and
                                   qop != 'query-running')) else True)
            if not iflist and qop == 'query-running':
                iflist = [i for i in os.listdir('/sys/class/net/')
                          if os.path.isdir('/sys/class/net/%s' % i)]
            log.debug('creating ifupdown object ..')
            import ifupdown.ifupdownmain
            ifupdown_handle = ifupdown.ifupdownmain.ifupdownMain(config=configmap_g,
                                                                 withdepends=args.withdepends,
                                                                 perfmode=args.perfmode,
                                                                 cache=cachearg,
                                                                 interfacesfile=self.interfaces_filename,
                                                                 interfacesfileiobuf=self.interfaces_file_iobuf,
                                                                 interfacesfileformat=args.interfacesfileformat,
                                                                 withdefaults=args.withdefaults)
            # list implies all auto interfaces (this is how ifupdown behaves)
            if args.list:
                args.all = True
            ifupdown_handle.query([qop], args.all, args.list, args.CLASS, iflist,
                                  excludepats=args.excludepats,
                                  printdependency=args.printdependency,
                                  format=args.format, type=args.type)
        except:
            raise

    def run_reload(self, args):
        log.debug('args = %s' % str(args))

        try:
            log.debug('creating ifupdown object ..')
            import ifupdown.ifupdownmain
            ifupdown_handle = ifupdown.ifupdownmain.ifupdownMain(config=configmap_g,
                                                                 interfacesfile=self.interfaces_filename,
                                                                 withdepends=args.withdepends,
                                                                 perfmode=args.perfmode,
                                                                 dryrun=args.noact)
            ifupdown_handle.reload(['pre-up', 'up', 'post-up'],
                                   ['pre-down', 'down', 'post-down'],
                                   auto=args.all, allow=args.CLASS, ifacenames=None,
                                   excludepats=args.excludepats,
                                   usecurrentconfig=args.usecurrentconfig,
                                   syntaxcheck=args.syntaxcheck,
                                   currentlyup=args.currentlyup)
        except:
            raise


class Daemon:
    shutdown_event = threading.Event()

    def __init__(self):
        self.uds = None
        self.context = None
        self.working_directory = '/var/run/ifupdown2d/'
        self.server_address = '/var/run/ifupdown2d/uds'

        if not os.path.exists(self.working_directory):
            log.info('creating %s' % self.working_directory)
            os.makedirs(self.working_directory, mode=0755)

        if os.path.exists(self.server_address):
            log.info('removing uds %s' % self.server_address)
            os.remove(self.server_address)

        self.context = daemon.DaemonContext(
            working_directory=self.working_directory,
            signal_map={
                signal.SIGINT: self.signal_handler,
                signal.SIGTERM: self.signal_handler,
                signal.SIGQUIT: self.signal_handler,
            }
        )

        try:
            self.SO_PEERCRED = socket.SO_PEERCRED
        except AttributeError:
            # powerpc is the only non-generic we care about. alpha, mips,
            # sparc, and parisc also have non-generic values.
            machine = os.uname()[4]
            if re.search(r'^(ppc|powerpc)', machine):
                self.SO_PASSCRED = 20
                self.SO_PEERCRED = 21
            else:
                self.SO_PASSCRED = 16
                self.SO_PEERCRED = 17

        log.info('daemonizing ifupdown2d...')
        self.context.open()

        log.info('preloading all necessary modules')
        self.preload_imports()

        try:
            log.info('opening UNIX socket')
            self.uds = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            fcntl.fcntl(self.uds.fileno(), fcntl.F_SETFD, fcntl.FD_CLOEXEC)
        except Exception as e:
            raise Exception('socket: %s' % str(e))
        try:
            self.uds.bind(self.server_address)
        except Exception as e:
            raise Exception('bind: %s' % str(e))
        try:
            self.uds.setsockopt(socket.SOL_SOCKET, self.SO_PASSCRED, 1)
        except Exception as e:
            raise Exception('setsockopt: %s' % str(e))
        try:
            self.uds.listen(1)
        except Exception as e:
            raise Exception('listen: %s' % str(e))
        os.chmod(self.server_address, 0777)

    def __del__(self):
        if self.context:
            self.context.close()
        if self.uds:
            self.uds.close()

    @staticmethod
    def preload_imports():
        """
            preloading all the necessary modules
            at first will increase performances
        """
        import io
        import pdb
        import imp
        import sets
        import json
        import glob
        import time
        import copy
        import errno
        import pprint
        import atexit
        import ipaddr
        import cPickle
        import logging
        import argparse
        import StringIO
        import datetime
        import traceback
        import itertools
        import subprocess
        import argcomplete
        import collections
        import ConfigParser
        import pkg_resources

        import ifupdown.exceptions
        import ifupdown.graph
        import ifupdown.iface
        import ifupdown.iff
        import ifupdown.ifupdownbase
        import ifupdown.ifupdownbase
        import ifupdown.ifupdownconfig
        import ifupdown.ifupdownflags
        import ifupdown.ifupdownmain
        import ifupdown.netlink
        import ifupdown.networkinterfaces
        import ifupdown.policymanager
        import ifupdown.scheduler
        import ifupdown.statemanager
        import ifupdown.template
        import ifupdown.utils

        import ifupdownaddons.bondutil
        import ifupdownaddons.bridgeutils
        import ifupdownaddons.cache
        import ifupdownaddons.dhclient
        import ifupdownaddons.iproute2
        import ifupdownaddons.modulebase
        import ifupdownaddons.mstpctlutil
        import ifupdownaddons.systemutils
        import ifupdownaddons.utilsbase

    @staticmethod
    def signal_handler(sig, frame):
        log.info('received %s' % 'SIGINT' if sig == signal.SIGINT else 'SIGTERM')
        Daemon.shutdown_event.set()

    @staticmethod
    def user_waiting_for_reply():
        return not log.is_syslog()

    def run(self):
        try:
            while True:
                if Daemon.shutdown_event.is_set():
                    log.info("shutdown signal RXed, breaking out loop")
                    break

                try:
                    (client_socket, client_address) = self.uds.accept()
                except socket.error as e:
                    log.error(str(e))
                    break

                pid = os.fork()
                if pid == 0:
                    exit(self.ifupdown2(client_socket))
                else:
                    log.tx_data(json.dumps({'pid': pid}), socket=client_socket)

                    start = datetime.datetime.now()
                    status = os.WEXITSTATUS(os.waitpid(pid, 0)[1])
                    end = datetime.datetime.now()

                    log.tx_data(json.dumps({'status': status}), socket=client_socket)
                    client_socket.close()

                    log.info('exit status %d - in %ssecs'
                             % (status, (end - start).total_seconds()))

        except Exception as e:
            log.error(e)
        self.uds.close()

    def get_client_uid(self, client_socket):
        creds = client_socket.getsockopt(socket.SOL_SOCKET, self.SO_PEERCRED, struct.calcsize('3i'))
        (pid, uid, gid) = struct.unpack('3i', creds)
        log.debug('client uid %d' % uid)
        return uid

    @staticmethod
    def get_client_request(client_socket):
        """
            This function handles requests of any length.

                if the received json is longer than 65k it will be truncated
                several calls to recv will be needed, we store the data until
                we can decode them with the json library.
        """
        data = []
        while True:
            log.debug('waiting for request on client socket')
            ready = select.select([client_socket], [], [])

            if ready and ready[0] and ready[0][0] == client_socket:
                # data available start reading
                raw_data = client_socket.recv(65536)

                try:
                    return json.loads(raw_data)
                except ValueError:
                    # the json is incomplete
                    data.append(raw_data)

                    if len(data) > 1:
                        try:
                            return json.loads(''.join(data))
                        except ValueError:
                            pass

    def ifupdown2(self, client_socket):
        try:
            fcntl.fcntl(client_socket.fileno(), fcntl.F_SETFD, fcntl.FD_CLOEXEC)

            ifupdown2 = Ifupdown2(self.get_client_uid(client_socket))
            ifupdown2.set_signal_handlers()

            request = self.get_client_request(client_socket)
            log.info('request: %s' % request['argv'])

            ifupdown2.parse_argv(request['argv'])
            # adjust the logger with argv
            ifupdown2.update_logger(client_socket)

            try:
                status = ifupdown2.main(request)
            except Exception as e:
                log.error(str(e))
                status = 1

        except ifupdown.argv.ArgvParseError as e:
            log.update_current_logger(syslog=False, verbose=True, debug=False)
            log.set_socket(client_socket)
            e.log_error()
            status = 1
        except Exception as e:
            log.error(e)
            status = 1

        log.flush()
        log.set_socket(None)
        client_socket.close()
        return status


if __name__ == '__main__':
    try:
        os.putenv('PATH', Ifupdown2.ENVPATH)
        resource.setrlimit(resource.RLIMIT_CORE, (0, 0))
        Daemon().run()
    except Exception as e:
        print e
        log.error(str(e))
        import traceback
        log.error(traceback.format_exc())
        exit(1)
