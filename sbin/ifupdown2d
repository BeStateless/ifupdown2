#!/usr/bin/python
#
# Copyright 2014 Cumulus Networks, Inc. All rights reserved.
# Authors:
#           Roopa Prabhu, roopa@cumulusnetworks.com
#           Julien Fortin, julien@cumulusnetworks.com
#
# ifupdown --
#    tool to configure network interfaces
#

# preloading all the necessary modules
# at first will increase performances
import os
import io
import re
import sys
import pdb
import imp
import sets
import json
import glob
import time
import copy
import fcntl
import shlex
import errno
import pprint
import atexit
import ipaddr
import signal
import socket
import cPickle
import logging
import argparse
import StringIO
import resource
import datetime
import threading
import traceback
import itertools
import subprocess
import argcomplete
import collections
import ConfigParser
import pkg_resources

import ifupdown.argv
import ifupdown.exceptions
import ifupdown.graph
import ifupdown.iface
import ifupdown.iff
import ifupdown.ifupdownbase
import ifupdown.ifupdownbase
import ifupdown.ifupdownconfig
import ifupdown.ifupdownflags
import ifupdown.ifupdownmain
import ifupdown.log
import ifupdown.netlink
import ifupdown.networkinterfaces
import ifupdown.policymanager
import ifupdown.scheduler
import ifupdown.statemanager
import ifupdown.template
import ifupdown.utils

import ifupdownaddons.bondutil
import ifupdownaddons.bridgeutils
import ifupdownaddons.cache
import ifupdownaddons.dhclient
import ifupdownaddons.iproute2
import ifupdownaddons.modulebase
import ifupdownaddons.mstpctlutil
import ifupdownaddons.systemutils
import ifupdownaddons.utilsbase

from threading import Event

from ifupdown.log import log
from ifupdown.utils import *
from ifupdown.argv import Parse
from ifupdown.ifupdownmain import *


lockfile="/run/network/.lock"
configfile="/etc/network/ifupdown2/ifupdown2.conf"
configmap_g=None
logger = log
interfacesfileiobuf=None
interfacesfilename=None
ENVPATH = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"


def run_up(args):
    logger.debug('args = %s' %str(args))

    try:
        iflist = args.iflist
        if len(args.iflist) == 0:
            iflist = None
        logger.debug('creating ifupdown object ..')
        cachearg=(False if (iflist or args.nocache or
                            args.perfmode or args.noact)
                            else True)
        ifupdown_handle = ifupdownMain(config=configmap_g,
                                       force=args.force,
                                       withdepends=args.withdepends,
                                       perfmode=args.perfmode,
                                       dryrun=args.noact,
                                       cache=cachearg,
                                       addons_enable=not args.noaddons,
                                       statemanager_enable=not args.noaddons,
                                       interfacesfile=interfacesfilename,
                                       interfacesfileiobuf=interfacesfileiobuf,
                                       interfacesfileformat=args.interfacesfileformat)
        if args.noaddons:
            ifupdown_handle.up(['up'], args.all, args.CLASS, iflist,
                               excludepats=args.excludepats,
                               printdependency=args.printdependency,
                               syntaxcheck=args.syntaxcheck, type=args.type,
                               skipupperifaces=args.skipupperifaces)
        else:
            ifupdown_handle.up(['pre-up', 'up', 'post-up'],
                               args.all, args.CLASS, iflist,
                               excludepats=args.excludepats,
                               printdependency=args.printdependency,
                               syntaxcheck=args.syntaxcheck, type=args.type,
                               skipupperifaces=args.skipupperifaces)
    except:
        raise

def run_down(args):
    logger.debug('args = %s' %str(args))

    try:
        iflist = args.iflist
        logger.debug('creating ifupdown object ..')
        ifupdown_handle = ifupdownMain(config=configmap_g, force=args.force,
                                       withdepends=args.withdepends,
                                       perfmode=args.perfmode,
                                       dryrun=args.noact,
                                       addons_enable=not args.noaddons,
                                       statemanager_enable=not args.noaddons,
                                       interfacesfile=interfacesfilename,
                                       interfacesfileiobuf=interfacesfileiobuf,
                                       interfacesfileformat=args.interfacesfileformat)

        ifupdown_handle.down(['pre-down', 'down', 'post-down'],
                             args.all, args.CLASS, iflist,
                             excludepats=args.excludepats,
                             printdependency=args.printdependency,
                             usecurrentconfig=args.usecurrentconfig,
                             type=args.type)
    except:
        raise

def run_query(args):
    logger.debug('args = %s' %str(args))

    try:
        iflist = args.iflist
        if args.checkcurr:
            qop='query-checkcurr'
        elif args.running:
            qop='query-running'
        elif args.raw:
            qop='query-raw'
        elif args.syntaxhelp:
            qop = 'query-syntax'
        elif args.printdependency:
            qop = 'query-dependency'
        elif args.printsavedstate:
            qop = 'query-savedstate'
        else:
            qop='query'
        cachearg=(False if (iflist or args.nocache or
                            args.perfmode or args.syntaxhelp or
                            (qop != 'query-checkcurr' and
                            qop != 'query-running')) else True)
        if not iflist and qop == 'query-running':
            iflist = [i for i in os.listdir('/sys/class/net/')
                        if os.path.isdir('/sys/class/net/%s' %i)]
        logger.debug('creating ifupdown object ..')
        ifupdown_handle = ifupdownMain(config=configmap_g,
                                       withdepends=args.withdepends,
                                       perfmode=args.perfmode,
                                       cache=cachearg,
                                       interfacesfile=interfacesfilename,
                                       interfacesfileiobuf=interfacesfileiobuf,
                                       interfacesfileformat=args.interfacesfileformat,
                                       withdefaults=args.withdefaults)
        # list implies all auto interfaces (this is how ifupdown behaves)
        if args.list:
            args.all = True
        ifupdown_handle.query([qop], args.all, args.list, args.CLASS, iflist,
                              excludepats=args.excludepats,
                              printdependency=args.printdependency,
                              format=args.format, type=args.type)
    except:
        raise

def run_reload(args):
    logger.debug('args = %s' %str(args))

    try:
        logger.debug('creating ifupdown object ..')
        ifupdown_handle = ifupdownMain(config=configmap_g,
                                       interfacesfile=interfacesfilename,
                                       withdepends=args.withdepends,
                                       perfmode=args.perfmode,
                                       dryrun=args.noact)
        ifupdown_handle.reload(['pre-up', 'up', 'post-up'],
                               ['pre-down', 'down', 'post-down'],
                               auto=args.all, allow=args.CLASS, ifacenames=None,
                               excludepats=args.excludepats,
                               usecurrentconfig=args.usecurrentconfig,
                               syntaxcheck=args.syntaxcheck,
                               currentlyup=args.currentlyup)
    except:
        raise

def init(argv, args):
    global interfacesfileiobuf
    global interfacesfilename

    if hasattr(argv, 'interfacesfile') and args.interfacesfile != None:
        # Check to see if -i option is allowed by config file
        # But for ifquery, we will not check this
        if (not args[0].endswith('ifquery') and
                configmap_g.get('disable_cli_interfacesfile','0') == '1'):
            logger.error('disable_cli_interfacesfile is set so users '
                         'not allowed to specify interfaces file on cli.')
            raise Exception("")
        if args.interfacesfile == '-':
            # If interfaces file is stdin, read
            raise NotImplementedError()
            interfacesfileiobuf = sys.stdin.read()
        else:
            interfacesfilename = args.interfacesfile
    else:
        # if the ifupdown2 config file does not have it, default to standard
        interfacesfilename = configmap_g.get('default_interfaces_configfile',
                                             '/etc/network/interfaces')




def deinit():
    {}


handlers = {'up' : run_up,
            'down' : run_down,
            'query' : run_query,
            'reload' : run_reload }

def read_config(args):
    global configmap_g

    with open(configfile, 'r') as f:
        config = f.read()
    configStr = '[ifupdown2]\n' + config
    configFP =  StringIO.StringIO(configStr)
    parser = ConfigParser.RawConfigParser()
    parser.readfp(configFP)
    configmap_g = dict(parser.items('ifupdown2'))

    # Preprocess config map
    configval = configmap_g.get('multiple_vlan_aware_bridge_support', '0')
    if configval == '0':
        # if multiple bridges not allowed, set the bridge-vlan-aware
        # attribute in the 'no_repeats' config, so that the ifupdownmain
        # module can catch it appropriately
        configmap_g['no_repeats'] = {'bridge-vlan-aware' : 'yes'}


    configval = configmap_g.get('link_master_slave', '0')
    if configval == '1':
        # link_master_slave is only valid when all is set
        if hasattr(args, 'all') and not args.all:
            configmap_g['link_master_slave'] = '0'

    configval = configmap_g.get('delay_admin_state_change', '0')
    if configval == '1':
        # reset link_master_slave if delay_admin_state_change is on
        configmap_g['link_master_slave'] = '0'


def main(argv):
    """ main function """
    try:
        args_parse = Parse(argv)
        args_parse.validate()

        args = args_parse.get_args()
        op = args_parse.get_op()

        log.update_logger(args)

        #if not argv[0].endswith('ifquery') and not os.geteuid() == 0: --> send the euid of the user process
        #    logger.error('error: must be root to run this command')
        #    return 1

        #if not sys.argv[0].endswith('ifquery') and not utils.lockFile(lockfile):
        #    log.error('Another instance of this program is already running.')
        #    exit(0)

        read_config(args)
        init(argv, args)
        handlers.get(op)(args)
    except ArgvParseError as e:
        e.log_error()
    except Exception, e:
        log.info(e) # to remove
        if not str(e):
            return 1
        if args and args.debug:
            raise
        else:
            if logger:
                logger.error(str(e))
            else:
                print str(e)
            #if args and not args.debug:
            #    print '\nrerun the command with \'-d\' for a detailed errormsg'
        return 1
    finally:
        deinit()
    return 0

class Daemon:
    shutdown_event = Event()

    def __init__(self, argv):
        self.uds = None
        self.context = None
        self.working_directory = '/var/run/ifupdown2d/'
        self.server_address = '/var/run/ifupdown2d/uds'

        if not os.path.exists(self.working_directory):
            log.info('creating %s' % self.working_directory)
            os.makedirs(self.working_directory, mode=0755)

        if os.path.exists(self.server_address):
            log.info('removing uds %s' % self.server_address)
            os.remove(self.server_address)

        from daemon import DaemonContext

        self.context = DaemonContext(
            working_directory=self.working_directory,
            signal_map={
                signal.SIGTERM: Daemon.signal_handler,
                signal.SIGINT: Daemon.signal_handler,
            },
        )

        try:
            self.SO_PEERCRED = socket.SO_PEERCRED
        except AttributeError:
            # powerpc is the only non-generic we care about. alpha, mips,
            # sparc, and parisc also have non-generic values.
            machine = os.uname()[4]
            if re.search(r'^(ppc|powerpc)', machine):
                self.SO_PASSCRED = 20
                self.SO_PEERCRED = 21
            else:
                self.SO_PASSCRED = 16
                self.SO_PEERCRED = 17

        log.info('daemonizing ifupdown2d...')
        self.context.open()

        log.info('creating UNIX socket %s...' % self.server_address)
        try:
            self.uds = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            fcntl.fcntl(self.uds.fileno(), fcntl.F_SETFD, fcntl.FD_CLOEXEC)
        except Exception as e:
            raise Exception('socket: %s' % str(e))
        try:
            self.uds.bind(self.server_address)
        except Exception as e:
            raise Exception('bind: %s' % str(e))
        try:
            self.uds.setsockopt(socket.SOL_SOCKET, self.SO_PASSCRED, 1)
        except Exception as e:
            raise Exception('setsockopt: %s' % str(e))
        try:
            self.uds.listen(1)
        except Exception as e:
            raise Exception('listen: %s' % str(e))
        os.chmod(self.server_address, 0777)

    def __del__(self):
        if self.context:
            self.context.close()
        if self.uds:
            self.uds.close()

    @staticmethod
    def signal_handler(sig, frame):
        log.info('received %s' % 'SIGINT' if sig == signal.SIGINT else 'SIGTERM')
        Daemon.shutdown_event.set()

    def reset(self):
        global configmap_g
        global interfacesfileiobuf
        global interfacesfilename
        configmap_g = None
        interfacesfileiobuf = None
        interfacesfilename = None

    def user_waiting_for_reply(self):
        return not log.syslog_mode()

    def sigint_set_shutdown(self, e):
        # 4 is 'Interrupted system call', this means the accept caught the SIGINT
        if isinstance(e.args, tuple):
            if e[0] == 4:
                log.info("socket.accept() caught signal, starting shutdown")
            else:
                raise e
        else:
            raise e

    def run(self):
        try:
            while True:
                if Daemon.shutdown_event.is_set():
                    log.info("shutdown signal RXed, breaking out loop")
                    break

                try:
                    (connection, client_address) = self.uds.accept()
                except socket.error as e:
                    self.sigint_set_shutdown(e)
                    break
                pid = os.fork()
                if pid == 0:
                    fcntl.fcntl(connection.fileno(), fcntl.F_SETFD, fcntl.FD_CLOEXEC)
                    try:
                        self.reset()
                        code = self.request(connection, connection.recv(4096))
                    except Exception as e:
                        log.error(e)
                        code = 1
                    exit(code)
                else:
                    connection.close()
                    os.waitpid(pid, 0)
        except Exception as e:
            log.error(e)
        self.uds.close()

    def request(self, connection, data):
        argv = shlex.split(data)
        log.info('request: %s' % argv)

        start = datetime.datetime.now()
        try:
            code = main(argv)
        except Exception as e:
            log.error(str(e))
            code = 1
        end = datetime.datetime.now()

        result = {
            'code': code,
            'stdout': '',
            'stderr': '',
        }
        if self.user_waiting_for_reply():
            result['stdout'] = log.get_stdout_buffer()
            result['stderr'] = log.get_stderr_buffer()

        connection.sendall(json.dumps(result))

        log.flush()
        log.update_logger(args=None, verbose=True, syslog=True)

        delta = end - start
        log.info('exit status %d - in %ssecs' % (code, delta.total_seconds()))

        connection.close()
        log.debug('closing socket')
        return code


if __name__ == '__main__':
    try:
        os.putenv('PATH', ENVPATH)
        resource.setrlimit(resource.RLIMIT_CORE, (0, 0))
        Daemon(sys.argv).run()
    except Exception as e:
        print e
        log.error(e)
        exit(1)
