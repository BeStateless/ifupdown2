#!/usr/bin/python
#
# Copyright 2017 Cumulus Networks, Inc. All rights reserved.
# Authors:
#           Roopa Prabhu, roopa@cumulusnetworks.com
#           Julien Fortin, julien@cumulusnetworks.com
#
# ifupdown2 --
#    tool to configure network interfaces
#

import os
import re
import json
import fcntl
import struct
import signal
import socket
import daemon
import select
import datetime
import threading
import traceback

import cumulus.sdnotify

try:
    import ifupdown2.ifupdown.argv

    from ifupdown2.ifupdown.log import log
    from ifupdown2.ifupdown.main import Ifupdown2
    from ifupdown2.ifupdown.exceptions import ArgvParseError, ArgvParseHelp
except ImportError:
    import ifupdown.argv

    from ifupdown.log import log
    from ifupdown.main import Ifupdown2
    from ifupdown.exceptions import ArgvParseError, ArgvParseHelp


class Daemon:
    shutdown_event = threading.Event()

    def __init__(self):
        self.uds = None
        self.context = None
        self.working_directory = '/var/run/ifupdown2d/'
        self.server_address = '/var/run/ifupdown2d/uds'

        self.signal_str_map = dict(
            (attr_value, attr_name)
            for attr_name, attr_value in signal.__dict__.items()
            if attr_name.startswith('SIG') and not attr_name.startswith('SIG_')
        )

        if not os.path.exists(self.working_directory):
            log.info('creating %s' % self.working_directory)
            os.makedirs(self.working_directory, mode=0755)

        if os.path.exists(self.server_address):
            log.info('removing uds %s' % self.server_address)
            os.remove(self.server_address)

        # FROM CHERRY-PICK 7aa2b547672ff
        self.__signal_map = {
            signal.SIGINT: self.signal_handler,
            signal.SIGTERM: self.signal_handler,
            signal.SIGQUIT: self.signal_handler,
        }

        self.context = daemon.DaemonContext(
            working_directory=self.working_directory,
            signal_map=self.__signal_map,
            umask=0o22
        )

        try:
            self.SO_PEERCRED = socket.SO_PEERCRED
        except AttributeError:
            # powerpc is the only non-generic we care about. alpha, mips,
            # sparc, and parisc also have non-generic values.
            machine = os.uname()[4]
            if re.search(r'^(ppc|powerpc)', machine):
                self.SO_PASSCRED = 20
                self.SO_PEERCRED = 21
            else:
                self.SO_PASSCRED = 16
                self.SO_PEERCRED = 17

        log.info('daemonizing ifupdown2d...')
        self.context.open()

        log.info('preloading all necessary modules')
        self.preload_imports()

        try:
            log.info('opening UNIX socket')
            self.uds = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            fcntl.fcntl(self.uds.fileno(), fcntl.F_SETFD, fcntl.FD_CLOEXEC)
        except Exception as e:
            raise Exception('socket: %s' % str(e))
        try:
            self.uds.bind(self.server_address)
        except Exception as e:
            raise Exception('bind: %s' % str(e))
        try:
            self.uds.setsockopt(socket.SOL_SOCKET, self.SO_PASSCRED, 1)
        except Exception as e:
            raise Exception('setsockopt: %s' % str(e))
        try:
            self.uds.listen(1)
        except Exception as e:
            raise Exception('listen: %s' % str(e))
        os.chmod(self.server_address, 0777)

        log.info('filling netlink cache')
        try:
            import ifupdown2.lib.nlcache as nlcache
        except:
            import lib.nlcache as nlcache

        # After the daemon is ready we can start our netlink listener
        nlcache.NetlinkListenerWithCache.get_instance()


    def __del__(self):
        if self.context:
            self.context.close()
        if self.uds:
            self.uds.close()

    @staticmethod
    def preload_imports():
        """
            preloading all the necessary modules
            at first will increase performances
        """
        try:
            import io
            import pdb
            import imp
            import sets
            import json
            import glob
            import time
            import copy
            import errno
            import pprint
            import atexit
            import ipaddr
            import cPickle
            import logging
            import argparse
            import StringIO
            import datetime
            import traceback
            import itertools
            import subprocess
            import argcomplete
            import collections
            import ConfigParser
            import pkg_resources

            try:
                import ifupdown2.ifupdown.exceptions
                import ifupdown2.ifupdown.graph
                import ifupdown2.ifupdown.iface
                import ifupdown2.ifupdown.iff
                import ifupdown2.ifupdown.ifupdownconfig
                import ifupdown2.ifupdown.ifupdownflags
                import ifupdown2.ifupdown.ifupdownmain
                import ifupdown2.ifupdown.netlink
                import ifupdown2.ifupdown.networkinterfaces
                import ifupdown2.ifupdown.policymanager
                import ifupdown2.ifupdown.scheduler
                import ifupdown2.ifupdown.statemanager
                import ifupdown2.ifupdown.template
                import ifupdown2.ifupdown.utils

                import ifupdown2.ifupdownaddons.cache
                import ifupdown2.ifupdownaddons.dhclient
                import ifupdown2.ifupdownaddons.mstpctlutil
                import ifupdown2.ifupdownaddons.LinkUtils
                import ifupdown2.ifupdownaddons.modulebase
                import ifupdown2.ifupdownaddons.systemutils
                import ifupdown2.ifupdownaddons.utilsbase
            except ImportError:
                import ifupdown.exceptions
                import ifupdown.graph
                import ifupdown.iface
                import ifupdown.iff
                import ifupdown.ifupdownconfig
                import ifupdown.ifupdownflags
                import ifupdown.ifupdownmain
                import ifupdown.netlink
                import ifupdown.networkinterfaces
                import ifupdown.policymanager
                import ifupdown.scheduler
                import ifupdown.statemanager
                import ifupdown.template
                import ifupdown.utils

                import ifupdownaddons.cache
                import ifupdownaddons.dhclient
                import ifupdownaddons.mstpctlutil
                import ifupdownaddons.LinkUtils
                import ifupdownaddons.modulebase
                import ifupdownaddons.systemutils
                import ifupdownaddons.utilsbase

        except ImportError, e:
            raise ImportError('%s - required module not found' % str(e))

    def signal_handler(self, sig, frame):
        log.set_socket(None)
        log.update_current_logger(syslog=True, verbose=True, debug=True)
        log.info("received %s signal" % self.signal_str_map.get(sig, "UNKNOWN"))
        Daemon.shutdown_event.set()

    @staticmethod
    def user_waiting_for_reply():
        return not log.is_syslog()

    def run(self):
        # Tell systemd that we are initialized and ready
        cumulus.sdnotify.sd_notify(0, "READY=1")

        try:
            for sig, sig_handler in self.__signal_map.iteritems():
                signal.signal(sig, sig_handler)

            while True:
                if Daemon.shutdown_event.is_set():
                    log.info("shutdown signal RXed, breaking out loop")
                    break

                try:
                    (client_socket, client_address) = self.uds.accept()
                except socket.error as e:
                    if not Daemon.shutdown_event.is_set():
                        log.error("daemon: socket: accept: %s" % str(e))
                    else:
                        log.info("shutdown signal RXed, breaking out loop")
                    break

                #if False:
                #    pid = os.fork()
                #    if pid == 0:
                #        exit(self.ifupdown2(client_socket, daemon=True))
                #    else:
                #        log.tx_data(json.dumps({'pid': pid}), socket=client_socket)
                #
                #        start = datetime.datetime.now()
                #        status = os.WEXITSTATUS(os.waitpid(pid, 0)[1])
                #        end = datetime.datetime.now()
                #
                #        log.tx_data(json.dumps({'status': status}), socket=client_socket)
                #        client_socket.close()
                #
                #        log.info('exit status %d - in %ssecs'
                #                 % (status, (end - start).total_seconds()))

                log.tx_data(json.dumps({'pid': os.getpid()}), socket=client_socket)
                start = datetime.datetime.now()
                try:
                    return_value = self.ifupdown2(client_socket, daemon=False)
                except Exception as e:
                    log.error('run exception: ' + str(e))
                    log.error('%s' % traceback.format_exc())

                    return_value = 1
                end = datetime.datetime.now()
                log.update_current_logger(syslog=True, verbose=True, debug=True)
                log.tx_data(json.dumps({'status': return_value}), socket=client_socket)
                client_socket.close()
                log.info('exit status %d - in %ssecs'
                         % (return_value, (end - start).total_seconds()))

        except Exception as e:
            log.error(e)
        self.uds.close()

    def get_client_uid(self, client_socket):
        creds = client_socket.getsockopt(socket.SOL_SOCKET, self.SO_PEERCRED, struct.calcsize('3i'))
        (pid, uid, gid) = struct.unpack('3i', creds)
        log.debug('client uid %d' % uid)
        return uid

    @staticmethod
    def get_client_request(client_socket):
        """
            This function handles requests of any length.

                if the received json is longer than 65k it will be truncated
                several calls to recv will be needed, we store the data until
                we can decode them with the json library.
        """
        data = []
        while True:
            log.debug('waiting for request on client socket')
            ready = select.select([client_socket], [], [])

            if ready and ready[0] and ready[0][0] == client_socket:
                # data available start reading
                raw_data = client_socket.recv(65536)

                try:
                    return json.loads(raw_data)
                except ValueError:
                    # the json is incomplete
                    data.append(raw_data)

                    if len(data) > 1:
                        try:
                            return json.loads(''.join(data))
                        except ValueError:
                            pass

    def ifupdown2(self, client_socket, daemon):

        try:
            fcntl.fcntl(client_socket.fileno(), fcntl.F_SETFD, fcntl.FD_CLOEXEC)

            ifupdown2 = Ifupdown2(daemon=True, uid=self.get_client_uid(client_socket))

            request = self.get_client_request(client_socket)
            log.info('request: %s' % request['argv'])

            # set socket now in case we have an error in parse_argv
            log.set_socket(client_socket)

            if "dump" in request['argv']:
                log.update_current_logger(syslog=False, verbose=True, debug=True)

                try:
                    import ifupdown2.lib.nlcache as nlcache
                except:
                    import lib.nlcache as nlcache
                netlink = nlcache.NetlinkListenerWithCache.get_instance()

                try:
                    from ifupdownaddons.cache import linkCache

                except:
                    from ifupdown2.ifupdownaddons.cache import linkCache

                log.error('OLDCACHE=%s' % linkCache.links)

                try:
                    log.error('nlcache_ifname_by_ifindex=%s' % netlink.cache._ifname_by_ifindex)
                except Exception as e:
                    log.error('A=%s' % e)
                try:
                    log.error('_ifindex_by_ifname=%s' % netlink.cache._ifindex_by_ifname)
                except Exception as e:
                    log.error('B=%s' % e)
                try:
                    log.error('_masters_and_slaves=%s' % netlink.cache._masters_and_slaves)
                except Exception as e:
                    log.error('C=%s' % e)
                log.error('')
                try:
                    log.error('CACHE=%s' % netlink.cache._link_cache)
                except Exception as e:
                    log.error('D=%s' % e)

                try:
                    log.error('ADDR=%s' % netlink.cache._addr_cache)
                except Exception as e:
                    log.error('E=%s' % e)
                log.error('')
                log.error('')


                try:
                    index = request['argv'].index('dump')
                    if index + 1 <= len(request['argv']):
                        index += 1

                    target = request['argv'][index]

                    netlink.cache.DEBUG_IFNAME(target, with_addresses=True)

                    log.error('')
                    log.error('')
                    log.error('')
                    log.error('CACHE[%s]=%s' % (target, linkCache.links[target]))
                except:
                    pass

                log.error('')
                log.error('')
                log.error('')
                log.error('')

                return 42

            ifupdown2.parse_argv(request['argv'])

            # adjust the logger with argv
            ifupdown2.update_logger(socket=client_socket)

            try:
                status = ifupdown2.main(request['stdin'])
            except BaseException as e:
                log.error('ifupdown2.main: %s' % str(e))
                status = 1
                log.flush()
                if daemon:
                    log.set_socket(None)
                    client_socket.close()
                return status

        except ArgvParseHelp:
            # on --help parse_args raise SystemExit we catch it and raise
            # a custom exception ArgvParseHelp so we can properly return 0
            status = 0
        except ArgvParseError as e:
            log.update_current_logger(syslog=False, verbose=True, debug=False)
            e.log_error()
            status = 1
        except Exception as e:
            log.error('Exception=%s' % traceback.format_exc())
            log.error(e)
            status = 2
        except BaseException as e:
            log.error('BaseException=%s' % traceback.format_exc())
            log.error(e)
            status = 3

        log.flush()
        if daemon:
            log.set_socket(None)
            client_socket.close()
        return status


if __name__ == '__main__':

    try:
        Daemon().run()
    except BaseException as e:
        print e
        log.error(str(e))
        log.error(traceback.format_exc())
        exit(1)
    finally:
        try:
            import ifupdown2.lib.nlcache as nlcache
        except:
            import lib.nlcache as nlcache

        nlcache.NetlinkListenerWithCache.get_instance().cleanup()
